{
  "version": 3,
  "sources": ["../../jstps/index.js"],
  "sourcesContent": ["/**\r\n * A jsTPS_Transaction represents a single atomic transaction to be managed\r\n * by the jsTPS class in a transaction stack. Each transaction can be done\r\n * and the undone, which should restore the state of the application employing\r\n * this framework.\r\n * \r\n * @author TheMcKillaGorilla\r\n * @version 2.0.4\r\n */\r\nexport class jsTPS_Transaction {\r\n    /**\r\n     * This method is called by jsTPS when a transaction is executed.\r\n     */\r\n    executeDo() {\r\n        console.log(\"executeDo - MISSING IMPLEMENTATION\");\r\n    }\r\n\r\n    /**\r\n     * This method is called by jsTPS when a transaction is undone.\r\n     */\r\n    executeUndo() {\r\n        console.log(\"executeUndo - MISSING IMPLEMENTATION\");\r\n    }\r\n}\r\n\r\n/**\r\n * jsTPS serves as a transaction processing system employing a transaction\r\n * stack such that one can use this framework to implement undo/redo in\r\n * an application.\r\n * \r\n * @author TheMcKillaGorilla\r\n * @version 2.0\r\n */\r\nexport class jsTPS {\r\n    /**\r\n     * Thrown when one tries to undo, or redo a transaction when\r\n     * none is available for such an operation.\r\n     */\r\n    TRANSACTION_STACK_EXCEPTION = \"TRANSACTION_STACK_EXCEPTION\";\r\n\r\n    /**\r\n     * A Transaction Processing System to be used for implementing\r\n     * undo/redo in a JavaScript application. Note that the transaction\r\n     * stack will start out empty, with no transactions to do or undo.\r\n     * @constructor\r\n     */\r\n     constructor() {\r\n        // THE TRANSACTION STACK, MEANING TRANSACTIONS THAT HAVE BEEN\r\n        // EXECUTED THAT WE CAN UNDO AND THEN REDO\r\n        this.transactions = [];\r\n\r\n        // THE TOTAL NUMBER OF VALID TRANSACTIONS IN THE STACK, INCLUDING THOSE \r\n        // THAT WE MIGHT REDO, BUT NOT INCLUDING TRANSACTIONS THAT ARE LOST WHEN \r\n        // BRANCHING OCCURS, MEANING WHEN WE HAVE UNDONE TRANSACTIONS AND THEN\r\n        // ADD A NEW ONE, WHICH ELIMINATES THOSE ABOVE IT IN THE STACK. NOTE THAT\r\n        // THIS NUMBER ONLY CHANGES WHEN WE ADD A TRANSACTION.\r\n        this.size = 0;\r\n\r\n        // THE INDEX WHERE A NEW TRANSACTION WOULD BE ADDED ONTO THE STACK\r\n        // SHOULD processTransaction BE CALLED, WHICH ADDES AND EXECUTES A\r\n        // TRANSACTION. NOTE THAT FOLLOWING COMBINATIONS OF UNDO AND REDO \r\n        // THIS INDEX WILL BE ONE MORE THAN THE INDEX OF THE MOST RECENTLY\r\n        // DONE TRANSACTION.\r\n        this.topIndex = 0;\r\n    }\r\n\r\n    /**\r\n     * Completely resets the transaction stack, assigning it a new, empty array and\r\n     * resetting the top index and size to reflect an empty stack.\r\n     */\r\n    clearAllTransactions() {\r\n        // REMOVE ALL THE TRANSACTIONS\r\n        this.transactions = [];\r\n        \r\n        // RESET THE OTHER VARIABLES TOO\r\n        this.topIndex = 0;      \r\n        this.size = 0; \r\n    }\r\n\r\n    /**\r\n     * Executes the transaction in the stack where our index is and advances the index such\r\n     * that it could then be undone if necessary. Note, this does not change what\r\n     * transactions are on the stack, just the index counter that keeps track of\r\n     * what has been done and undone.\r\n     * \r\n     * @throws {TRANSACTION_STACK_EXCEPTION} thrown if there is no transaction on the\r\n     * stack to do.\r\n     */\r\n    doTransaction() {\r\n        if (this.hasTransactionToDo()) {\r\n            let transaction = this.transactions[this.topIndex];\r\n            transaction.executeDo();\r\n            this.topIndex++;\r\n        }\r\n        else {\r\n            throw this.TRANSACTION_STACK_EXCEPTION;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Accessor method for the number of transactions that can currently be done.\r\n     * \r\n     * @returns {Number} The number of transactions in the stack that can be done.\r\n     */\r\n    getDoSize() {\r\n        return this.getSize() - this.getUndoSize();\r\n    }\r\n\r\n    /**\r\n     * Accessor method for the total number of transactions in the current stack which\r\n     * includes those that can be done and undone.\r\n     * \r\n     * @returns {Number} The number of transactions in total in the stack.\r\n     */\r\n    getSize() {\r\n        return this.size;\r\n    }\r\n\r\n    /**\r\n     * Accessor method for the number of transactions that can currently be undone.\r\n     * \r\n     * @returns {Number} The number of transactions in the stack that can be undone.\r\n     */\r\n    getUndoSize() {\r\n        return this.topIndex;\r\n    }\r\n\r\n    /**\r\n     * Used to check if there is an doable transaction in the stack or not, like\r\n     * to redo a transaction, which might be useful for an application for enabling\r\n     * a redo button.\r\n     * \r\n     * @returns true if there is a transaction in the stack that can be done,\r\n     * false othewise.\r\n     */\r\n    hasTransactionToDo() {\r\n        return (this.getDoSize() > 0);\r\n    }\r\n\r\n    /**\r\n     * Used to check if there is an undoable transaction in the stack or not, like\r\n     * to undo a transaction, which might be useful for an application for enabling\r\n     * an undo button.\r\n     * \r\n     * @returns true if there is a transaction in the stack that can be undone,\r\n     * false otherwise.\r\n     */\r\n    hasTransactionToUndo() {\r\n        return (this.getUndoSize() > 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a transaction in the stack at a provided index without executing the transaction\r\n     * or changing the stack.\r\n     * \r\n     * @param {Number} index = The index of the transaction in the stack to get, which can\r\n     * be used to get any transaction, even those that have been undone if they are still\r\n     * in the stack.\r\n     * \r\n     * @returns {jsTPS_Transaction} The transaction to retrieve at index in the stack, if\r\n     * an invalid index is provided, null is returned.\r\n     */\r\n    peekTransaction(index) {\r\n        if ((index >= 0) && (index < this.getSize())) {\r\n            return this.transactions[index];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * This function takes the transaction argument and both pushes it to the top of the\r\n     * transaction stack and executes it. After this method executes one can undo it, but\r\n     * there should be no transaction to redo as this one will have been executed.\r\n     * @param {jsTPS_Transaction} transaction - The transaction to add to the stack and execute.\r\n     */\r\n    processTransaction(transaction) {\r\n        // FIRST ADD THE TRANSACTION TO THE STACK\r\n        this.transactions[this.topIndex] = transaction;\r\n\r\n        // NOW WE NEED TO UPDATE THE SIZE OF THE STACK, WHICH AFTER A TRANSACTION\r\n        // IS PUSHED ONTO THE TOP, WILL ALWAYS BE TWO MORE THAN topIndex, SINCE\r\n        // THE TRANSACTION HAS NOT YET BEEN EXECUTED.\r\n        this.size = this.topIndex + 1;\r\n\r\n        // AND THEN EXECUTE IT, WHICH WILL ALSO MOVE THE TOP INDEX\r\n        this.doTransaction();\r\n    }\r\n\r\n    /**\r\n     * Builds and returns a textual representation of the transaction processing\r\n     * system, which summarizes the contents of the transaction stack.\r\n     * \r\n     * @returns {String} A textual representation of the transaction stack.\r\n     */\r\n    toString() {        \r\n        let text = \"--Number of Transactions: \" + this.size + \"\\n\";\r\n        text += \"--Top Index: \" + this.topIndex + \"\\n\";\r\n        text += \"--Current Transaction Stack:\\n\";\r\n        for (let i = 0; i <= this.topIndex; i++) {\r\n            let jT = this.transactions[i];\r\n            text += \"----\" + jT.toString() + \"\\n\";\r\n        }\r\n        return text;        \r\n    }\r\n\r\n    /**\r\n     * Undoes the transaction at the top of the stack and decrements the index such\r\n     * that it could then be redone if necessary. Note, this does not change what\r\n     * transactions are on the stack, just the index counter that keeps track of\r\n     * the top of the stack, and thus which transactions would be executed for do\r\n     * and undo operations.\r\n     * \r\n     * @throws {TRANSACTION_STACK_EXCEPTION} thrown if there is no transaction on the\r\n     * stack to undo.\r\n     */\r\n    undoTransaction() {\r\n        if (this.hasTransactionToUndo()) {\r\n            let transaction = this.transactions[this.topIndex-1];\r\n            transaction.executeUndo();\r\n            this.topIndex--;\r\n        }\r\n        else {\r\n            throw this.TRANSACTION_STACK_EXCEPTION;\r\n        }\r\n    }\r\n}"],
  "mappings": ";;;AASO,IAAM,oBAAN,MAAwB;AAAA;AAAA;AAAA;AAAA,EAI3B,YAAY;AACR,YAAQ,IAAI,oCAAoC;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACV,YAAQ,IAAI,sCAAsC;AAAA,EACtD;AACJ;AAUO,IAAM,QAAN,MAAY;AAAA;AAAA;AAAA;AAAA;AAAA,EAKf,8BAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ7B,cAAc;AAGX,SAAK,eAAe,CAAC;AAOrB,SAAK,OAAO;AAOZ,SAAK,WAAW;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,uBAAuB;AAEnB,SAAK,eAAe,CAAC;AAGrB,SAAK,WAAW;AAChB,SAAK,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,gBAAgB;AACZ,QAAI,KAAK,mBAAmB,GAAG;AAC3B,UAAI,cAAc,KAAK,aAAa,KAAK,QAAQ;AACjD,kBAAY,UAAU;AACtB,WAAK;AAAA,IACT,OACK;AACD,YAAM,KAAK;AAAA,IACf;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY;AACR,WAAO,KAAK,QAAQ,IAAI,KAAK,YAAY;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU;AACN,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc;AACV,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,qBAAqB;AACjB,WAAQ,KAAK,UAAU,IAAI;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,uBAAuB;AACnB,WAAQ,KAAK,YAAY,IAAI;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,gBAAgB,OAAO;AACnB,QAAK,SAAS,KAAO,QAAQ,KAAK,QAAQ,GAAI;AAC1C,aAAO,KAAK,aAAa,KAAK;AAAA,IAClC;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,mBAAmB,aAAa;AAE5B,SAAK,aAAa,KAAK,QAAQ,IAAI;AAKnC,SAAK,OAAO,KAAK,WAAW;AAG5B,SAAK,cAAc;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,WAAW;AACP,QAAI,OAAO,+BAA+B,KAAK,OAAO;AACtD,YAAQ,kBAAkB,KAAK,WAAW;AAC1C,YAAQ;AACR,aAAS,IAAI,GAAG,KAAK,KAAK,UAAU,KAAK;AACrC,UAAI,KAAK,KAAK,aAAa,CAAC;AAC5B,cAAQ,SAAS,GAAG,SAAS,IAAI;AAAA,IACrC;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,kBAAkB;AACd,QAAI,KAAK,qBAAqB,GAAG;AAC7B,UAAI,cAAc,KAAK,aAAa,KAAK,WAAS,CAAC;AACnD,kBAAY,YAAY;AACxB,WAAK;AAAA,IACT,OACK;AACD,YAAM,KAAK;AAAA,IACf;AAAA,EACJ;AACJ;",
  "names": []
}
